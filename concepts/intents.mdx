---
title: "Intents"
description: "The unit of work in Lattice -- structured proposals that flow through classification and governance before execution."
---

An **Intent** is the unit of work in Lattice. It is a durable declaration of something the system proposes to do, ask, or improve. Nothing happens without an Intent -- it is the boundary between reasoning and side effects.

## Why Intents?

Intents provide a structured way to:

- **Propose actions** before executing them
- **Classify risk** automatically based on what the action touches
- **Gate execution** through the safety framework
- **Track history** with a full audit trail of transitions
- **Enable human oversight** for high-risk operations

## Intent Kinds

| Kind | Purpose | Default Classification |
|------|---------|----------------------|
| `:action` | Produces side effects (deploy, scale, modify) | Determined by capability/operation |
| `:inquiry` | Requests human input or secrets | Always `:controlled` |
| `:maintenance` | Proposes system improvements | Always `:safe` |
| `:doc_update` | Documentation updates triggered by drift detection | Always `:safe` |

### Action Intents

Actions require:

- `summary` -- what the action will do
- `payload` -- includes `"capability"` and `"operation"` keys for classification
- `affected_resources` -- non-empty list of resources that will be modified
- `expected_side_effects` -- non-empty list of expected outcomes

```elixir
Lattice.Intents.Intent.new_action(
  %{type: :sprite, id: "sprite-001"},
  summary: "Wake sprite for deployment",
  payload: %{"capability" => "sprites", "operation" => "wake"},
  affected_resources: ["sprite-001"],
  expected_side_effects: ["sprite-001 transitions to :waking"]
)
```

## Lifecycle State Machine

```
proposed → classified → awaiting_approval → approved → running → completed
                      ↘ approved ──────────────────────────────↗
                                                                 ↘ failed
```

| State | Meaning |
|-------|---------|
| `:proposed` | Intent created, not yet classified |
| `:classified` | Safety classification applied |
| `:awaiting_approval` | Requires human approval |
| `:approved` | Cleared for execution |
| `:running` | Currently executing |
| `:completed` | Successfully finished |
| `:failed` | Execution failed |
| `:rejected` | Human rejected the intent |
| `:canceled` | Canceled before execution |

Terminal states: `:completed`, `:failed`, `:rejected`, `:canceled`.

## The Pipeline

### 1. Propose

```elixir
{:ok, intent} = Pipeline.propose(intent)
```

Creates the intent and auto-advances through classification and gating.

### 2. Classify

Maps the intent to a safety level using `payload["capability"]` and `payload["operation"]`.

### 3. Gate

Applies the [Safety Gate](/guides/safety) rules:

- **SAFE** intents auto-advance to `:approved`
- **CONTROLLED** intents go to `:awaiting_approval` (if configured)
- **DANGEROUS** intents always go to `:awaiting_approval`

### 4. Approve / Reject / Cancel

```elixir
Pipeline.approve(intent_id, actor: "operator-1", reason: "Approved for deploy")
Pipeline.reject(intent_id, actor: "operator-1", reason: "Not needed")
Pipeline.cancel(intent_id, actor: "operator-1", reason: "Superseded")
```

## Events

Each lifecycle transition emits:

- A **Telemetry event** on `[:lattice, :intent, <state>]`
- A **PubSub broadcast** on `"intents:<intent_id>"` and `"intents:all"`

## Sources

| Source Type | Meaning |
|------------|---------|
| `:sprite` | Generated by a Sprite observation |
| `:agent` | Submitted by an external agent |
| `:cron` | Triggered by a scheduled task |
| `:operator` | Created by a human operator |
