defmodule Lattice.Intents.Plan do
  @moduledoc """
  A structured execution plan attached to an intent.

  Plans contain ordered steps that track progress during intent execution.
  Each plan has a version counter that increments on every step update,
  enabling optimistic concurrency and change tracking.

  ## Sources

  - `:agent` — plan generated by an AI agent (default)
  - `:operator` — plan created by a human operator
  - `:system` — plan generated by the system automatically

  ## Rendered Markdown

  Plans maintain a pre-rendered markdown representation that uses checkbox
  notation for step status: `[x]` completed, `[~]` running, `[!]` failed,
  `[-]` skipped, `[ ]` pending.
  """

  alias Lattice.Intents.Plan.Step

  @valid_sources [:agent, :operator, :system]

  @type t :: %__MODULE__{
          title: String.t(),
          steps: [Step.t()],
          source: :agent | :operator | :system,
          version: pos_integer(),
          rendered_markdown: String.t()
        }

  @enforce_keys [:title, :steps, :source]
  defstruct [:title, :rendered_markdown, steps: [], source: :agent, version: 1]

  @doc """
  Create a new plan with a title, steps, and optional source.

  Steps can be `%Step{}` structs or keyword lists with at least a `:description` key.
  """
  @spec new(String.t(), [Step.t() | keyword()], atom()) :: {:ok, t()} | {:error, term()}
  def new(title, steps, source \\ :agent)

  def new(title, steps, source)
      when is_binary(title) and is_list(steps) and source in @valid_sources do
    case normalize_steps(steps) do
      {:ok, step_structs} ->
        {:ok,
         %__MODULE__{
           title: title,
           steps: step_structs,
           source: source,
           version: 1,
           rendered_markdown: render_markdown(title, step_structs)
         }}

      {:error, _} = error ->
        error
    end
  end

  @doc """
  Update the status of a step within the plan.

  Increments the plan version and re-renders the markdown.
  """
  @spec update_step_status(t(), String.t(), atom(), term()) :: {:ok, t()} | {:error, term()}
  def update_step_status(%__MODULE__{} = plan, step_id, status, output \\ nil) do
    valid = Step.valid_statuses()

    cond do
      status not in valid ->
        {:error, {:invalid_step_status, status}}

      not Enum.any?(plan.steps, &(&1.id == step_id)) ->
        {:error, {:step_not_found, step_id}}

      true ->
        updated_steps = apply_step_update(plan.steps, step_id, status, output)

        {:ok,
         %{
           plan
           | steps: updated_steps,
             version: plan.version + 1,
             rendered_markdown: render_markdown(plan.title, updated_steps)
         }}
    end
  end

  @doc "Returns the list of valid plan sources."
  @spec valid_sources() :: [atom()]
  def valid_sources, do: @valid_sources

  @doc "Convert a Plan struct to a plain map."
  @spec to_map(t()) :: map()
  def to_map(%__MODULE__{} = plan) do
    %{
      title: plan.title,
      steps: Enum.map(plan.steps, &Step.to_map/1),
      source: plan.source,
      version: plan.version,
      rendered_markdown: plan.rendered_markdown
    }
  end

  @doc "Reconstruct a Plan from a string-keyed map."
  @spec from_map(map()) :: {:ok, t()} | {:error, term()}
  def from_map(%{"title" => title, "steps" => steps, "source" => source} = map)
      when is_binary(title) and is_list(steps) do
    with {:ok, parsed_source} <- parse_source(source),
         {:ok, step_structs} <- parse_steps(steps) do
      {:ok,
       %__MODULE__{
         title: title,
         steps: step_structs,
         source: parsed_source,
         version: Map.get(map, "version", 1),
         rendered_markdown:
           Map.get(map, "rendered_markdown", render_markdown(title, step_structs))
       }}
    end
  end

  def from_map(_), do: {:error, :invalid_plan}

  @doc "Render markdown for a plan title and steps."
  @spec render_markdown(String.t(), [Step.t()]) :: String.t()
  def render_markdown(title, steps) do
    header = "## #{title}\n\n"

    step_lines =
      steps
      |> Enum.with_index(1)
      |> Enum.map_join("\n", fn {step, idx} ->
        checkbox = status_checkbox(step.status)
        skill_tag = if step.skill, do: " `[#{step.skill}]`", else: ""
        "#{idx}. #{checkbox} #{step.description}#{skill_tag}"
      end)

    header <> step_lines
  end

  # ── Private ──────────────────────────────────────────────────────

  defp apply_step_update(steps, step_id, status, output) do
    Enum.map(steps, fn step ->
      if step.id == step_id do
        %{step | status: status, output: output || step.output}
      else
        step
      end
    end)
  end

  defp normalize_steps(steps) do
    steps
    |> Enum.reduce_while({:ok, []}, fn
      %Step{} = step, {:ok, acc} ->
        {:cont, {:ok, acc ++ [step]}}

      opts, {:ok, acc} when is_list(opts) ->
        case Keyword.fetch(opts, :description) do
          {:ok, desc} ->
            {:ok, step} = Step.new(desc, opts)
            {:cont, {:ok, acc ++ [step]}}

          :error ->
            {:halt, {:error, {:missing_step_description, opts}}}
        end

      invalid, _acc ->
        {:halt, {:error, {:invalid_step, invalid}}}
    end)
  end

  defp parse_source(source) when is_binary(source) do
    atom = String.to_existing_atom(source)

    if atom in @valid_sources do
      {:ok, atom}
    else
      {:error, {:invalid_plan_source, source}}
    end
  rescue
    ArgumentError -> {:error, {:invalid_plan_source, source}}
  end

  defp parse_source(source) when is_atom(source) and source in @valid_sources, do: {:ok, source}
  defp parse_source(source), do: {:error, {:invalid_plan_source, source}}

  defp parse_steps(steps) do
    steps
    |> Enum.reduce_while({:ok, []}, fn step_map, {:ok, acc} ->
      case Step.from_map(step_map) do
        {:ok, step} -> {:cont, {:ok, acc ++ [step]}}
        {:error, _} = error -> {:halt, error}
      end
    end)
  end

  defp status_checkbox(:completed), do: "[x]"
  defp status_checkbox(:running), do: "[~]"
  defp status_checkbox(:failed), do: "[!]"
  defp status_checkbox(:skipped), do: "[-]"
  defp status_checkbox(_), do: "[ ]"
end
