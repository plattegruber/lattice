---
title: "Architecture"
description: "System overview, event model, capability modules, and process supervision in Lattice."
---

Lattice is built on Elixir/OTP, leveraging the BEAM's process model for concurrent, fault-tolerant management of AI coding agents.

<Info>
**Sprites emit signals. Lattice makes decisions.**

Sprites are the execution layer. Lattice is the control plane that classifies, gates, and audits every action.
</Info>

## System Overview

```
┌─────────────────────────────────────────────────┐
│                  Phoenix/LiveView                │
│         (Fleet Dashboard, Sprite Detail,         │
│          Incidents, Approvals Queue)             │
├─────────────────────────────────────────────────┤
│                  Fleet Manager                   │
│         (DynamicSupervisor, Registry)            │
├──────────┬──────────┬──────────┬────────────────┤
│ Sprite 1 │ Sprite 2 │ Sprite N │  (GenServers)  │
├──────────┴──────────┴──────────┴────────────────┤
│              Capability Modules                  │
│   GitHubCapability │ FlyCapability │ SpritesAPI  │
├─────────────────────────────────────────────────┤
│         Telemetry + PubSub (Event Bus)           │
├─────────────────────────────────────────────────┤
│              Safety & Guardrails                 │
│     (Action Classification, Gating, Audit)       │
└─────────────────────────────────────────────────┘
```

| Concern | Lattice (Control Plane) | Sprites (Execution) |
|---------|------------------------|---------------------|
| **Decides** what to do | Yes | No |
| **Executes** skills | No | Yes |
| **Classifies** risk | Yes | No |
| **Requires** approval | Yes | No |
| **Emits** events | Yes | Yes |

## Key Mental Models

### Sprites Are Processes

Each Sprite gets a GenServer that owns its state, runs reconciliation, and emits events. The BEAM provides isolation, supervision, and fault tolerance.

### Events Are Truth

State changes emit Telemetry events. PubSub broadcasts them. LiveView subscribes and renders. No polling, ever.

### Capabilities Are Behaviours

Each external system gets a **behaviour module** -- a bounded interface that enables clean mocking, auto-selection of live vs. stub implementations, and future extensibility.

### Safety Is First-Class

Every action flows through the classify-gate-audit pipeline. This is a core architectural concern, not a bolt-on.

## Process Supervision Tree

```
Application Supervisor
├── Lattice.PubSub                    (Phoenix.PubSub)
├── LatticeWeb.Endpoint               (Phoenix endpoint)
├── Lattice.Events.TelemetryHandler    (attaches Telemetry handlers)
├── Lattice.Intents.Store.ETS         (intent persistence)
├── Lattice.Intents.Governance.Listener (watches for approved intents)
├── Lattice.Sprites.Registry           (process registry)
├── Lattice.Sprites.DynamicSupervisor  (sprite supervisor)
├── Lattice.Sprites.FleetManager       (fleet coordinator)
└── Lattice.Docs.DriftDetector         (documentation drift monitoring)
```

## Event Infrastructure

### Telemetry

Events follow the `[:lattice, <domain>, <event>]` naming convention:

| Event | Emitted When |
|-------|-------------|
| `[:lattice, :sprite, :state_change]` | Sprite observed state transitions |
| `[:lattice, :sprite, :reconciliation]` | Reconciliation cycle completes |
| `[:lattice, :sprite, :health]` | Sprite health status changes |
| `[:lattice, :fleet, :summary]` | Fleet summary is recomputed |
| `[:lattice, :intent, :proposed]` | New intent is proposed |
| `[:lattice, :intent, :classified]` | Intent receives classification |
| `[:lattice, :intent, :approved]` | Intent is approved |
| `[:lattice, :intent, :awaiting_approval]` | Intent needs human review |
| `[:lattice, :safety, :audit]` | Capability action is audit-logged |

### PubSub Topics

| Topic | Messages |
|-------|----------|
| `"sprites:fleet"` | `{:fleet_summary, summary}` |
| `"sprites:<sprite_id>"` | State changes, reconciliation results, health updates |
| `"intents:all"` | All intent lifecycle transitions |
| `"intents:<intent_id>"` | Specific intent transitions |
| `"safety:audit"` | Audit entries |
| `"docs:drift"` | Documentation drift detections |

## Capability Modules

Each capability follows this pattern:

```
Lattice.Capabilities.<Name>           (behaviour definition)
├── Lattice.Capabilities.<Name>.Live  (real implementation)
└── Lattice.Capabilities.<Name>.Stub  (test/dev implementation)
```

| Capability | Purpose |
|-----------|---------|
| Sprites | Interact with the Sprites API (list, wake, sleep, exec) |
| GitHub | GitHub issues, labels, comments for HITL workflows |
| Fly | Fly.io operations (logs, status, deploy) |
| Secret Store | Secure credential access |

Capabilities are auto-selected at runtime based on available credentials.

## Intent Pipeline

```
Observation → Intent proposed → Classify → Gate → Execute → Audit
                                              ↓
                                    Await approval (if needed)
```

See the [Intents](/concepts/intents) concept page for full details.

## Tech Stack

| Layer | Technology |
|-------|-----------|
| Language | Elixir 1.18+ / OTP 27+ |
| Web | Phoenix 1.7+ / LiveView 1.0+ |
| Process model | GenServer, DynamicSupervisor, Registry |
| Events | `:telemetry` + Phoenix.PubSub |
| Persistence | ETS (intents, projects), process state (sprites) |
| Auth | Bearer token (API) |
| Deployment | Fly.io + Fly Scheduled Machines |
| CI | GitHub Actions |

## Design Principles

1. **Walking Skeleton First** -- thinnest possible vertical slice that works end-to-end
2. **Observable by Default** -- every state change emits events, no hidden state
3. **Safe Boundaries** -- classify, gate, and audit every action
4. **Processes, Not Services** -- OTP is the runtime, not Kubernetes
5. **Events Are Truth** -- state changes flow through Telemetry and PubSub
6. **GitHub as Human Substrate** -- issues for approval workflows
7. **Minimal Persistence Early** -- ETS and process state first, PostgreSQL later
8. **Vertical PRs Only** -- every change ships as a complete vertical slice
