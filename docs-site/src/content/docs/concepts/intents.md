---
title: Intents
description: The unit of work in Lattice -- structured proposals that flow through classification and governance before execution.
---

An **Intent** is the unit of work in Lattice. It is a durable declaration of something the system proposes to do, ask, or improve. Nothing happens without an Intent -- it is the boundary between reasoning and side effects.

## Why Intents?

Intents provide a structured way to:

- **Propose actions** before executing them
- **Classify risk** automatically based on what the action touches
- **Gate execution** through the safety framework
- **Track history** with a full audit trail of transitions
- **Enable human oversight** for high-risk operations

## Intent Kinds

Every intent has a **kind** that determines its nature and classification behavior:

| Kind | Purpose | Default Classification |
|------|---------|----------------------|
| `:action` | Produces side effects (deploy, scale, modify) | Determined by capability/operation |
| `:inquiry` | Requests human input or secrets | Always `:controlled` |
| `:maintenance` | Proposes system improvements | Always `:safe` |

### Action Intents

Actions are the most common kind. They produce side effects in external systems. An action intent requires:

- `summary` -- what the action will do
- `payload` -- includes `"capability"` and `"operation"` keys for classification
- `affected_resources` -- non-empty list of resources that will be modified
- `expected_side_effects` -- non-empty list of expected outcomes

```elixir
Lattice.Intents.Intent.new_action(
  %{type: :sprite, id: "sprite-001"},
  summary: "Wake sprite for deployment",
  payload: %{"capability" => "sprites", "operation" => "wake"},
  affected_resources: ["sprite-001"],
  expected_side_effects: ["sprite-001 transitions to :waking"]
)
```

### Inquiry Intents

Inquiries request information from a human operator. The payload must include:

- `"what_requested"` -- what information is needed
- `"why_needed"` -- justification for the request
- `"scope_of_impact"` -- what will be affected by the response
- `"expiration"` -- when the request expires

### Maintenance Intents

Maintenance intents propose system improvements without immediate urgency. They require only a `summary` and `payload`.

## Lifecycle State Machine

All intents start in `:proposed` and move through a governed state machine:

```
proposed → classified → awaiting_approval → approved → running → completed
                      ↘ approved ──────────────────────────────↗
                                                                 ↘ failed
```

| State | Meaning |
|-------|---------|
| `:proposed` | Intent created, not yet classified |
| `:classified` | Safety classification applied |
| `:awaiting_approval` | Requires human approval |
| `:approved` | Cleared for execution |
| `:running` | Currently executing |
| `:completed` | Successfully finished |
| `:failed` | Execution failed |
| `:rejected` | Human rejected the intent |
| `:canceled` | Canceled before execution |

Terminal states: `:completed`, `:failed`, `:rejected`, `:canceled`.

## The Pipeline

The `Lattice.Intents.Pipeline` module drives intents through their lifecycle:

### 1. Propose

```elixir
{:ok, intent} = Pipeline.propose(intent)
```

Creates the intent in the store and auto-advances through classification and gating.

### 2. Classify

Maps the intent to a safety level:

- **Action intents** use `payload["capability"]` and `payload["operation"]` to look up classification in the Safety Classifier registry
- **Inquiry intents** are always `:controlled`
- **Maintenance intents** are always `:safe`

If an action intent's capability/operation is not in the classifier registry, it defaults to `:controlled` for safety.

### 3. Gate

Applies the [Safety Gate](/lattice/guides/safety/) rules:

- **SAFE** intents auto-advance to `:approved`
- **CONTROLLED** intents go to `:awaiting_approval` (if approval is required by config)
- **DANGEROUS** intents always go to `:awaiting_approval`

### 4. Approve / Reject / Cancel

Human operators can act on pending intents:

```elixir
Pipeline.approve(intent_id, actor: "operator-1", reason: "Approved for deploy")
Pipeline.reject(intent_id, actor: "operator-1", reason: "Not needed")
Pipeline.cancel(intent_id, actor: "operator-1", reason: "Superseded")
```

## Events

Each lifecycle transition emits:

- A **Telemetry event** on `[:lattice, :intent, <state>]` (e.g., `[:lattice, :intent, :proposed]`)
- A **PubSub broadcast** on `"intents:<intent_id>"` and `"intents:all"`

This enables the LiveView dashboard to show real-time intent activity without polling.

## Sources

Intents track their origin through a `source` field:

| Source Type | Meaning |
|------------|---------|
| `:sprite` | Generated by a Sprite observation |
| `:agent` | Submitted by an external agent |
| `:cron` | Triggered by a scheduled task |
| `:operator` | Created by a human operator |

## Observations to Intents

[Observations](/lattice/concepts/sprites/#observations) from Sprites can automatically generate Intent proposals through the configured `IntentGenerator`. This closes the loop between Sprite sensing and the Intent governance pipeline:

```
Sprite observes → Observation emitted → IntentGenerator evaluates
    → Intent proposed → Pipeline classifies → Gate decides
```
